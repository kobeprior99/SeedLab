// SEED DEMO #1  *no PI communication
// Localization and Controls
// Cooper Hammond and Ron Gaines

// Demo 1 Instructions
const float instructions[3] = {2, 45, 3}; // distance in feet, angle to turn in degrees, distance in feet

// Pin definitions
const int enablePin = 4;    // Pin 4 to enable the motor driver
const int pwmPin[2] = {9, 10};      // Pin 9 for PWM control (Motor 1), Pin 10 for PWM control (Motor 2)
const int dirPin[2] = {7, 8};      // Pin 7 for direction control (Motor 1), Pin 8 for direction control (Motor 2)

// Encoder pins (one per motor)
const int encPin1A = 2; // Encoder pin A for motor 1
const int encPin2A = 3; // Encoder pin A for motor 2
const int encPin1B = 5; // Encoder pin B for motor 1
const int encPin2B = 6; // Encoder pin B for motor 2

// Timing variables
unsigned long desired_Ts_ms = 10;  // Desired sample time in milliseconds
unsigned long last_time_ms;
unsigned long start_time_ms;
float current_time;

// Array variables [motor1, motor2]
  //volatile
volatile int pos_counts[2] = {0, 0};
volatile int prev_counts[2] = {0, 0};
  //set in error correction
float pos_error[2] = {0, 0};
float integral_error[2] = {0, 0};
float desired_speed[2] = {0, 0};
float error[2] = {0, 0};
float Voltage[2] = {0, 0};
  //calculations
float desired_pos[2] = {0, 0}; //need to write code for
float actual_pos[2] = {0, 0}; //is pos_counts in radians
float prev_actual_pos[2] = {0, 0}; //is prev_counts in radians
float delta_pos[2] = {0, 0};
float actual_speed[2] = {0, 0};
float PWM[2] = {0, 0};

// Array Constants [motor1, motor2]
const float K[2] = {1.5, 1.75};
const float sigma[2] = {14, 14};
const float Kp[2] = {1.75, 2};
const float P[2] = {4.2, 4};
const float I[2] = {0.1, 0.1};

// Constants
const float Battery_Voltage = 7.8;
const float circumference = 2 * PI * (5.93/2); //distance: Measured 5.93in diameter -> c=2(pi)r -> 18.63
const float b = 12; //wheel base 12inches

// Position initialized
float lastXPos = 0.0, lastYPos = 0.0, lastAngle = 0.0;
float currentPos = 0.0;

// Timing variable for data reading incrementation
unsigned long last_read_time = 0;
const unsigned long read_interval = 100; 

//Boolean Tasks
bool task_1_done = false;
bool task_2_done = false;
bool task_3_done = false;

//FSM 
enum State {FOWARD1, TURN, FOWARD2, STOP};
State state = FOWARD1; //starting in state 1

//Calculate Desired Endpoint For Demo 1
float instruct1Radians = instructions[1] * (PI /180); //degress to radians
float x = instructions[0] + ( instructions[2] * cos(instruct1Radians) );
float y = ( instructions[2] * sin(instruct1Radians) );
float desired_endpoint = sqrt((x*x) + (y*y));

void setup() {
  // Initialize Serial communication
  Serial.begin(115200); // Set baud rate to 115200 for fast data output
  Serial.println("This sexy ass robot is ready to fuck some shit up!!!");

  Serial.print("Desired endpoint on xy-grid: ");
  Serial.print(x);
  Serial.print(", ");
  Serial.println(y);
  
  // Set motor control pins as outputs
  pinMode(enablePin, OUTPUT);
  pinMode(pwmPin[0], OUTPUT);
  pinMode(pwmPin[1], OUTPUT);
  pinMode(dirPin[0], OUTPUT);
  pinMode(dirPin[1], OUTPUT);

  // Set encoder pins as inputs
  pinMode(encPin1A, INPUT);
  pinMode(encPin2A, INPUT);
  
  // Enable the motor driver by setting the enable pin HIGH
  digitalWrite(enablePin, HIGH);

  // Initialize timing
  last_time_ms = millis();  // Record the start time for the first sample
  start_time_ms = last_time_ms;

  // Attach interrupts to encoder pins
  attachInterrupt(digitalPinToInterrupt(encPin1A), encoder1_ISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(encPin2A), encoder2_ISR, CHANGE);
}

// Functions

// Interrupt service routines (ISR) for counting encoder pulses
void encoder1_ISR() {
  if (digitalRead(encPin1A) == digitalRead(encPin1B)) {
    pos_counts[0] -= 2; // Clockwise rotation
  } else {
    pos_counts[0] += 2; // Counter-clockwise rotation
  }
}

void encoder2_ISR() {
  if (digitalRead(encPin2A) == digitalRead(encPin2B)) {
    pos_counts[1] += 2; // Counter-clockwise rotation
  } else {
    pos_counts[1] -= 2; // Clockwise rotation
  }
}

void loop() {
  
  // Calculate how far each wheel has traveled linearly in inches
  float wheel1Dist = ((float)pos_counts[0] / 3200) * circumference;
  float wheel2Dist = ((float)pos_counts[1] / 3200) * circumference;

  // Check if movement occurred
  bool isMoving = (abs(wheel1Dist) > 0.001 || abs(wheel2Dist) > 0.001);

  // Variables to store the updated position and angle
  float currentXPos = lastXPos;
  float currentYPos = lastYPos;
  float currentAngle = lastAngle;

  // If movement detected, update position and angle
  if (isMoving) {
    currentAngle = lastAngle + ((wheel1Dist - wheel2Dist) / b);
    currentXPos = lastXPos + cos(lastAngle) * ( (wheel1Dist + wheel2Dist) / 2 );
    currentYPos = lastYPos + sin(lastAngle) * ( (wheel1Dist + wheel2Dist) / 2 );
    currentPos = sqrt(currentXPos * currentXPos + currentYPos * currentYPos);

    // Update last known values
    lastXPos = currentXPos;
    lastYPos = currentYPos;
    lastAngle = currentAngle;
  }

  // Convert angle to degrees for display
  float currentAngleDeg = currentAngle * (180 / PI);

  // Calculate elapsed time in seconds
  current_time = (float)(millis() - start_time_ms) / 1000.0;

  // Loops through calculations for each motor
  for (int i = 0; i < 2; i++) {
    // Positional and velocity calculations
    actual_pos[i] = 2 * PI * (float)pos_counts[i] / 3200;
    prev_actual_pos[i] = 2 * PI * (float)prev_counts[i] / 3200;
    delta_pos[i] = actual_pos[i] - prev_actual_pos[i];
    actual_speed[i] = delta_pos[i] / ((float)desired_Ts_ms / 1000);
    pos_error[i] = desired_pos[i] - actual_pos[i];
    integral_error[i] = integral_error[i] + pos_error[i] * ((float)desired_Ts_ms / 1000);
    desired_speed[i] = (P[i] * pos_error[i]) + (I[i] * integral_error[i]);
    error[i] = desired_speed[i] - actual_speed[i];
    Voltage[i] = Kp[i] * error[i];

    PWM[i] = 255 * abs(Voltage[i]) / Battery_Voltage;

    if (pos_error[i] > 0) {
      digitalWrite(dirPin[i], HIGH);
    } else {
      digitalWrite(dirPin[i], LOW);
    }

    analogWrite(pwmPin[i], min(PWM[i], 255));
  }

  // Reset Values
  prev_counts[0] = pos_counts[0];
  prev_counts[1] = pos_counts[1];

  // DEMO1 CODE HERE

//    Serial.print("Current State: ");
//    Serial.print(state);  // Print the current state
//
//    Serial.print("  Current Position (inches): ");
//    Serial.print(currentPos);  // Print how far it has traveled
//
//    Serial.print("  Current Angle (degrees): ");
//    Serial.println(currentAngle * (180 / PI));  // Print the current orientation

    // Finite State Machine (FSM)
    switch (state) { 
        case FOWARD1: // Move forward  
            if (task_1_done == false) {  
                desired_pos[0] = (instructions[0] / circumference) * 3200;  
                desired_pos[1] = (instructions[0] / circumference) * 3200;  
                if (abs(currentYPos - (instructions[0] * 12)) <= 0.75) {  
                    Serial.println("Task 1 Complete: Forward movement done!");  
                    task_1_done = true;  
                    state = 2;  // Move to turning state  
                }  
            }  
            break;  

        case TURN: // Turn  
            if (task_2_done == false && task_1_done == true) {  
                if (abs(currentAngleDeg - instructions[1]) > 0.5) {  //if angle not within halg degree margin error
                    digitalWrite(dirPin[0], HIGH);  
                    digitalWrite(dirPin[1], LOW);  
                    analogWrite(pwmPin[0], 50);  
                    analogWrite(pwmPin[1], 50);  
                    Serial.println("Turning...");  
                } else {  
                    Serial.println("Task 2 Complete: Turning done!");  
                    task_2_done = true;  
                    state = 3;  // Move to next state  
                }  
            }  
            break;  

        case FOWARD2: // Move forward again  
            if (task_3_done == false && task_2_done == true && task_1_done == true) {  
                desired_pos[0] += (instructions[2] / circumference) * 3200;  
                desired_pos[1] += (instructions[2] / circumference) * 3200;  
                if (abs(currentPos - (desired_endpoint / 12)) <= 0.75) {  
                    Serial.println("Task 3 Complete: Final movement done!");  
                    task_3_done = true;  
                    state = 4;  // Move to stop state  
                }  
            }  
            break;  

        case STOP: // Stop  
            Serial.println("Demo Complete!");  
            analogWrite(pwmPin[0], 0);  
            analogWrite(pwmPin[1], 0);  
            break;  
    }  


  // Wait until the next sample period
  while (millis() < last_time_ms + desired_Ts_ms) {
    // Idle loop to maintain timing
  }

  last_time_ms = millis(); // Update last timestamp
} // end void loop


// ANAYSIS:
// desired endpoint being a 2 parameter coordinate list not a single hypotunuse length

//  float desired_endpoint[2] = {x, y}; //xy-pos in feet
//  //example of use in foward2
//  ( abs(currentXPos - (desired_endpoint[0] / 12)) <= 0.75 ) && ( abs(currentYPos - (desired_endpoint[1] / 12)) <= 0.75 )

// - using the the stop command after each task has been complete for a certain time increment


